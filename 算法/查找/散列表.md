**散列表**

标签：【算法】【查找】



# 1. 散列表

使用查找散列的查找算法分为两步：

- 第一步：用散列函数将被查找的键转化为数组的一个索引。（理想情况下不同的键都能转化为不同的索引值）。
- 第二步：处理碰撞冲突的过程，两个方式: 拉链法 和 线性探测法。



# 2. 散列函数

1. 散列函数：这个过程会将键转化为数组的索引。以下M表示数组大小
2. 正整数：我们常使用除留余数法。
   - 因为很多时候数都不是随机的，==建议使用素数（M）==作为数组的大小来作为除留余数法的除数。

3. 浮点数：我们一般将其乘以M并四拾伍入得到一个0至M-1之间的索引值。
   - 缺点是键的高位影响较大，将键表示为二进制数然后再使用除留余数法。
4. JAVA 约定：每种数据类型都需要响应的散列函数。且每一种数据类型的hashCode()方法必须和equals()方法一致：
   - equals()相等的数据hashCode()必须相等。
   - hashCode()相等的数据equals()不一定相等。
5. 软缓存：如果hashCode计算起来比较费时，那么我们可以将每个键的散列值缓存起来。
   - JAVA的String对象的HashCode就是如此。
6. 一个优秀的散列法：
   - 一致性——等价的键必然产生相等的散列值。
   - 高效性——计算简便。
   - 均匀性——均匀地散列所有的键。

# 3. 碰撞处理

1. 第二部碰撞处理，就是处理两个或多个键的散列值相同的情况。
   - 基于拉链法的散列表
   - 基于线性探测法的散列表



## 3.1 拉链法



## 3.2 线性探测法

1. 用大小为M的数组保存N个键值对，其中M>N,我们依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为**开放地址散列表**。
2. 当碰撞时，我们直接检查散列表的下一个位置（将索引值加1）。这样的线性探测可能会产生三种结果：
   - 命中，该位置的键和被查找的键相同。
   - 未命中：键为空（该位置没有键）。
   - 继续查找：该位置的键和被查找的键不同。
3. 缺点就是当M的数组被塞满后，put就会风控循环了，所以说会动态调整数组的大小来保证使用率在1/8 或 1/2之间。





# 4. 调整数组大小

1. 拉链法：当N >= M/2时调用resize(2*M)，并在delete中(在N>0 && N <= M/8时)调用resize(M/2)。





# 5. 总结各种算法

![各种算法优劣势](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-02-140920.png)



