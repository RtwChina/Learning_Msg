**B树**

标签：【算法】【查找】

# 1.B树

1. 动态查找树主要有：二叉查找树，平衡二叉树，红黑树，B-Tree。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度有关。
2. 但是咱们有面对这样一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何**减少树的深度**（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。
3. ==B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率)。==

#2.外储存器
1. 计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。

2. 外存储器—磁盘是一种直接存取的存储设备(DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快

##2.1 磁盘的构造

1. 磁盘是一个扁平的圆盘(与电唱机的唱片类似)。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图中所示的6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。

   ![磁盘的构造](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-030537.png)

2. 当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了。

3. 一般磁盘分为固定头盘(磁头固定)和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。

4. 活动头盘(如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。

##2.2磁盘的读/写原理和效率

1. 磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。

2. 读/写磁盘上某一指定数据需要下面3个步骤：

- 首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。

- 如上图中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。

- 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。

3. 经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。访问某一具体信息，由3部分时间组成：

- 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。

- 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。

- 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s

4. 磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。**因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，**以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。

5. 所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。

# 3. B树概念
1. 国内很多人喜欢把B-tree译作B-树，而事实上是，B-tree就是指的B树。
2. B树是为实现高效的磁盘存取而设计的多叉平衡搜索树，数据库系统中非常重要。

# 3.1 B树定义
B树又叫平衡多路查找树。一棵m阶的B树（切勿简单的认为一棵m阶的B树是m叉树）的特性如下：
1. 树的每个结点最多含有m个孩子(m>=2);
2. 除根结点和叶子结点外，其它每个结点至少有[ceil(m/2)]个孩子(其中ceil(x)是一个取上限的函数)
3. 若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）
4. 所有叶子节点具有相同的深度，即树的高度h。这表明B树是平衡的。平衡性其实正是B树名字的来源，B表示的正是单词Balanced。叶子节点没有孩子和指向孩子的指针，这些节点也存在，也有元素。其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已
5. 每个非终端结点中包含有n个关键字信息：（n，P0，K1，P1，K2，P2，......，Kn，Pn），其中
- Ki(i=1...n)为关键字，且关键字按顺序升序排序K(i-1)<Ki。
- Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
- 关键字的个数n必须满足：[ceil(m/2)-1] <= n <= m-1.
 ![标准的B树](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-031758.png)






#4. B树举例
1. 为了简单，这里用少量数据构造一棵3叉树的形式，实际应用中的B树结点中关键字很多的。上面的图中比如根结点，其中17表示一个磁盘文件的文件名；小红方块表示这个17文件内容在硬盘中的存储位置；p1表示指向17左子树的指针。

![B树搜索算法](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-032054.png)

2. 假如每个盘块可以正好存放一个B树的结点（正好存放2个文件名）。那么一个BTNODE结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。

3. 下面，咱们来模拟下查找文件29的过程：

1. 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】    
2. 此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针p2。
3. 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】    
4. 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针p2。
5. 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】    
6. 此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。
7. 分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。

#5 向B树插入关键字
1. 可以看出B树每个节点中关键字的个数是有范围要求的，同时B树是平衡的。所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。
2. 我们这样来设计B树种对新关键字的插入：首先找到要插入的关键字应该插入的叶子节点（为方便描述，设这个叶子节点为u），如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前排在中间关键字u.keyt进行分裂，分裂成两个节点u1,u2；同时，==作为分裂标准的关键字u.keyt（中间键）会被上移到u的父节点中==，在u.keyt插入前，如果u的父节点未满，则直接插入即可；**如果u的父节点已满，则按照上面的方法对u的父节点分裂**，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。

##5.1 插入步骤 
1. F, S, Q可以被插入一个节点（也就是根节点）

   ![插入1](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-094802.png)

2. 插入关键字K，因为节点已满，所以在插入前，发生分裂，中间关键字Q上移，建立了一个新的根节点。

   ![插入2](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-094855.png)

3. 插入关键字C:

   ![插入3](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-094927.png)

4. 插入关键字L，L应该被插入到根节点的左侧的孩子中，因为此时该节点已满，所以在插入前，发生分裂：

   ![插入4](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-095217.png)

5. 插入关键字H, T, V，这个过程没有发生节点的分裂：

   ![插入5](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-095247.png)

6. 插入关键字W，W应该被插入到根节点的最右侧的孩子中，因为此时该节点已满，所以在插入前，关键字T上移，最右端的叶子节点发生分裂：

   ![插入6](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-095256.png)

7. 插入关键字M，M应该被插入到根节点的左起第2个孩子中，因为此时该节点已满，所以在插入前，发生分裂，分裂之后，中间关键字K上移，导致根节点发生分裂，树高增加1：

   ![插入7](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-095302.png)

8. 同样的道理，插入关键字R, N, P, A, B, X, Y：最终得到的B树如下：

![插入8](http://rtt-picture.oss-cn-hangzhou.aliyuncs.com/2019-02-03-095311.png)






#6. 从B树删除关键字
1. 删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。插入操作主要防止的是某个节点中关键字的个数太多，所以采用了分裂；删除则是要防止某个节点中，因删除了关键字而导致这个节点的关键字个数太少，所以采用了**==合并操作==。**



## 6.1 删除操作的情况
1. 情况1：如果要删除的关键字k在节点u中，而且u是叶子节点，那么直接删除k。
2. 情况2：如果要删除的关键字k在节点u中，而且u是内部节点，那么分以下3种情况讨论：

详见
https://blog.csdn.net/guoziqing506/article/details/64122287



## 6.2 删除操作总结

1. 基本原则是不能破坏关键字个数的限制。
2. 若在当前节点，找到了要删的关键字，且当前节点为内部节点。那么，如果有比较丰满的前驱或后继，借一个上来，再把要删的关键字降下去，在子树中递归删除。
   - 如果没有比较丰满的前驱或后继，则令前驱与后继合并，并把要删的关键字降下去，递归删除。
3. 若在当前节点中，还未找到要删的关键字，且当前节点为内部节点。那么去找下一步应该扫描的孩子，并判断这个孩子是否丰满，如果丰满继续扫描；
   - 如果不丰满，则看其有无丰满的兄弟，有的话，从父亲那里借一个，父亲再从其最丰满的兄弟借一个；如果没有丰满的兄弟，则合并，再令父亲下降，以保证B树的结构。

















